<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoEvent Animation Performance Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }
        
        .performance-dashboard {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 10000;
            min-width: 250px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-weight: bold;
        }
        
        .metric-good { color: #4CAF50; }
        .metric-warning { color: #ff9800; }
        .metric-bad { color: #f44336; }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .hero {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .hero h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            margin-bottom: 1rem;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1s ease-out 0.5s forwards;
        }
        
        .hero p {
            font-size: 1.2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.8s ease-out 1s forwards;
        }
        
        .scroll-sections {
            padding: 0;
        }
        
        .scroll-section {
            min-height: 80vh;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2rem 0;
            padding: 3rem 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            transform: translateY(100px);
            transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1);
            will-change: transform, opacity;
            contain: layout style paint;
        }
        
        .scroll-section.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .scroll-section.reduced-motion {
            transition: opacity 0.3s ease;
            transform: none !important;
        }
        
        .section-content {
            text-align: center;
            max-width: 600px;
        }
        
        .section-content h2 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #fff, #e0e0e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .section-content p {
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }
        
        .stagger-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .stagger-item {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            transform: translateY(40px);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            will-change: transform, opacity;
            contain: layout style paint;
        }
        
        .stagger-item.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .parallax-element {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            will-change: transform;
            contain: layout style paint;
        }
        
        .glass-card {
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.1),
                rgba(255, 255, 255, 0.05)
            );
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1.5rem;
            padding: 2rem;
            margin: 1rem 0;
            contain: layout style paint;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                transition-delay: 0.01ms !important;
            }
            
            .scroll-section {
                transform: none !important;
            }
            
            .stagger-item {
                transform: none !important;
            }
        }
        
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-panel button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .control-panel button:hover {
            background: #45a049;
        }
        
        .control-panel button:active {
            transform: scale(0.95);
        }
        
        /* Loading performance optimization */
        img, video {
            will-change: auto;
            contain: layout style;
        }
        
        /* CSS Containment for performance */
        .scroll-section, .stagger-item, .glass-card {
            contain: layout style paint;
        }
    </style>
</head>
<body>
    <!-- Performance Dashboard -->
    <div class="performance-dashboard" id="dashboard">
        <h3 style="margin-bottom: 10px; text-align: center;">🚀 Performance Monitor</h3>
        <div class="metric">
            <span>FPS:</span>
            <span class="metric-value" id="fps">--</span>
        </div>
        <div class="metric">
            <span>Memory:</span>
            <span class="metric-value" id="memory">--</span>
        </div>
        <div class="metric">
            <span>Observers:</span>
            <span class="metric-value" id="observers">0</span>
        </div>
        <div class="metric">
            <span>Scroll Events:</span>
            <span class="metric-value" id="scrollEvents">0</span>
        </div>
        <div class="metric">
            <span>Intersections:</span>
            <span class="metric-value" id="intersections">0</span>
        </div>
        <div class="metric">
            <span>Animated:</span>
            <span class="metric-value" id="animated">0</span>
        </div>
        <div class="metric">
            <span>Reduced Motion:</span>
            <span class="metric-value" id="reducedMotion">--</span>
        </div>
        <div class="metric">
            <span>Status:</span>
            <span class="metric-value metric-good" id="status">Monitoring...</span>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <h4 style="margin-bottom: 10px;">Controls</h4>
        <button onclick="performanceTest.toggleReducedMotion()">Toggle Reduced Motion</button>
        <button onclick="performanceTest.stressTest()">Stress Test</button>
        <button onclick="performanceTest.resetAnimations()">Reset Animations</button>
        <button onclick="performanceTest.generateReport()">Generate Report</button>
    </div>

    <!-- Hero Section -->
    <div class="hero">
        <div>
            <h1>GoEvent Animation Performance Test</h1>
            <p>Testing scroll animations, stagger effects, and performance optimization</p>
        </div>
    </div>

    <!-- Parallax Elements -->
    <div class="parallax-element" id="parallax1" style="top: 20%; left: 10%;"></div>
    <div class="parallax-element" id="parallax2" style="top: 60%; right: 10%;"></div>
    <div class="parallax-element" id="parallax3" style="top: 80%; left: 30%;"></div>

    <div class="container">
        <!-- Scroll Sections -->
        <div class="scroll-sections">
            <!-- Section 1: Basic Reveal -->
            <div class="scroll-section" data-section="1">
                <div class="section-content">
                    <h2>Scroll-Triggered Reveals</h2>
                    <p>This section tests basic scroll-triggered reveal animations using Intersection Observer API with optimized performance and proper cleanup.</p>
                </div>
            </div>

            <!-- Section 2: Stagger Animation -->
            <div class="scroll-section" data-section="2">
                <div class="section-content">
                    <h2>Stagger Animations</h2>
                    <p>Testing staggered animations for multiple elements with proper timing and easing.</p>
                    <div class="stagger-container">
                        <div class="stagger-item" data-stagger="item-1">
                            <h4>Item 1</h4>
                            <p>First staggered element</p>
                        </div>
                        <div class="stagger-item" data-stagger="item-2">
                            <h4>Item 2</h4>
                            <p>Second staggered element</p>
                        </div>
                        <div class="stagger-item" data-stagger="item-3">
                            <h4>Item 3</h4>
                            <p>Third staggered element</p>
                        </div>
                        <div class="stagger-item" data-stagger="item-4">
                            <h4>Item 4</h4>
                            <p>Fourth staggered element</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Section 3: Glass Morphism -->
            <div class="scroll-section" data-section="3">
                <div class="section-content">
                    <h2>Glass Morphism Effects</h2>
                    <p>Testing backdrop-filter performance with multiple glass cards.</p>
                    <div class="glass-card">
                        <h4>Glass Card 1</h4>
                        <p>Testing backdrop blur effects</p>
                    </div>
                    <div class="glass-card">
                        <h4>Glass Card 2</h4>
                        <p>Multiple glass elements performance</p>
                    </div>
                </div>
            </div>

            <!-- Section 4: Complex Animation -->
            <div class="scroll-section" data-section="4">
                <div class="section-content">
                    <h2>Complex Transform Animations</h2>
                    <p>Testing complex CSS transforms with hardware acceleration and proper will-change optimization.</p>
                </div>
            </div>

            <!-- Section 5: Memory Test -->
            <div class="scroll-section" data-section="5">
                <div class="section-content">
                    <h2>Memory Management Test</h2>
                    <p>This section tests proper cleanup of observers and event listeners to prevent memory leaks.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PerformanceTest {
            constructor() {
                this.frameCount = 0;
                this.startTime = performance.now();
                this.lastFrameTime = this.startTime;
                this.scrollEventCount = 0;
                this.intersectionEventCount = 0;
                this.animatedElementCount = 0;
                this.observerCount = 0;
                this.observers = new Set();
                this.animatedElements = new Set();
                
                this.prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                
                this.init();
            }
            
            init() {
                this.setupIntersectionObservers();
                this.setupScrollListeners();
                this.setupParallax();
                this.startPerformanceMonitoring();
                this.updateDashboard();
                
                console.log('🚀 Performance test initialized');
            }
            
            setupIntersectionObservers() {
                // Main scroll sections observer
                const sectionObserver = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            this.intersectionEventCount++;
                            
                            if (entry.isIntersecting) {
                                const element = entry.target;
                                const sectionId = element.getAttribute('data-section');
                                
                                if (!this.animatedElements.has(`section-${sectionId}`)) {
                                    this.animatedElements.add(`section-${sectionId}`);
                                    this.animatedElementCount++;
                                    
                                    if (this.prefersReducedMotion) {
                                        element.classList.add('reduced-motion');
                                        element.style.opacity = '1';
                                    } else {
                                        element.classList.add('visible');
                                    }
                                }
                            }
                        });
                        this.updateDashboard();
                    },
                    {
                        threshold: 0.1,
                        rootMargin: '0px 0px -100px 0px'
                    }
                );
                
                // Observe all scroll sections
                document.querySelectorAll('.scroll-section').forEach(section => {
                    sectionObserver.observe(section);
                });
                
                this.observers.add(sectionObserver);
                this.observerCount++;
                
                // Stagger items observer
                const staggerObserver = new IntersectionObserver(
                    (entries) => {
                        const visibleEntries = entries.filter(entry => entry.isIntersecting);
                        
                        visibleEntries.forEach((entry, index) => {
                            const element = entry.target;
                            const staggerId = element.getAttribute('data-stagger');
                            
                            if (!this.animatedElements.has(staggerId)) {
                                this.animatedElements.add(staggerId);
                                this.animatedElementCount++;
                                
                                setTimeout(() => {
                                    if (this.prefersReducedMotion) {
                                        element.style.opacity = '1';
                                        element.style.transform = 'none';
                                    } else {
                                        element.classList.add('visible');
                                    }
                                }, index * 100); // Stagger delay
                            }
                        });
                        
                        this.updateDashboard();
                    },
                    {
                        threshold: 0.2,
                        rootMargin: '0px 0px -50px 0px'
                    }
                );
                
                document.querySelectorAll('.stagger-item').forEach(item => {
                    staggerObserver.observe(item);
                });
                
                this.observers.add(staggerObserver);
                this.observerCount++;
            }
            
            setupScrollListeners() {
                // Throttled scroll handler
                let ticking = false;
                
                const scrollHandler = () => {
                    this.scrollEventCount++;
                    
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            // Update dashboard periodically
                            if (this.scrollEventCount % 10 === 0) {
                                this.updateDashboard();
                            }
                            ticking = false;
                        });
                        ticking = true;
                    }
                };
                
                window.addEventListener('scroll', scrollHandler, { passive: true });
            }
            
            setupParallax() {
                // Simple parallax effect for performance testing
                const parallaxElements = document.querySelectorAll('.parallax-element');
                
                const updateParallax = () => {
                    const scrollY = window.scrollY;
                    
                    parallaxElements.forEach((element, index) => {
                        const speed = 0.5 + (index * 0.2);
                        const yPos = -(scrollY * speed);
                        element.style.transform = `translateY(${yPos}px)`;
                    });
                };
                
                let parallaxTicking = false;
                window.addEventListener('scroll', () => {
                    if (!parallaxTicking) {
                        requestAnimationFrame(() => {
                            updateParallax();
                            parallaxTicking = false;
                        });
                        parallaxTicking = true;
                    }
                }, { passive: true });
            }
            
            startPerformanceMonitoring() {
                const measureFPS = (timestamp) => {
                    this.frameCount++;
                    
                    const elapsed = timestamp - this.startTime;
                    if (elapsed >= 1000) {
                        const fps = Math.round((this.frameCount * 1000) / elapsed);
                        document.getElementById('fps').textContent = fps;
                        document.getElementById('fps').className = `metric-value ${
                            fps >= 55 ? 'metric-good' : fps >= 30 ? 'metric-warning' : 'metric-bad'
                        }`;
                        
                        this.frameCount = 0;
                        this.startTime = timestamp;
                    }
                    
                    requestAnimationFrame(measureFPS);
                };
                
                requestAnimationFrame(measureFPS);
                
                // Memory monitoring
                if (performance.memory) {
                    setInterval(() => {
                        const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                        document.getElementById('memory').textContent = `${memoryMB} MB`;
                        document.getElementById('memory').className = `metric-value ${
                            memoryMB < 100 ? 'metric-good' : memoryMB < 200 ? 'metric-warning' : 'metric-bad'
                        }`;
                    }, 1000);
                } else {
                    document.getElementById('memory').textContent = 'N/A';
                }
            }
            
            updateDashboard() {
                document.getElementById('observers').textContent = this.observerCount;
                document.getElementById('scrollEvents').textContent = this.scrollEventCount;
                document.getElementById('intersections').textContent = this.intersectionEventCount;
                document.getElementById('animated').textContent = this.animatedElementCount;
                document.getElementById('reducedMotion').textContent = this.prefersReducedMotion ? 'ON' : 'OFF';
                
                // Update status based on performance
                const fps = parseInt(document.getElementById('fps').textContent);
                let status = 'Good';
                let statusClass = 'metric-good';
                
                if (fps < 30 && fps > 0) {
                    status = 'Poor FPS';
                    statusClass = 'metric-bad';
                } else if (fps < 55 && fps > 0) {
                    status = 'Warning';
                    statusClass = 'metric-warning';
                }
                
                const statusElement = document.getElementById('status');
                statusElement.textContent = status;
                statusElement.className = `metric-value ${statusClass}`;
            }
            
            toggleReducedMotion() {
                this.prefersReducedMotion = !this.prefersReducedMotion;
                console.log('Reduced motion toggled:', this.prefersReducedMotion);
                
                // Apply to all animated elements
                document.querySelectorAll('.scroll-section, .stagger-item').forEach(element => {
                    if (this.prefersReducedMotion) {
                        element.classList.add('reduced-motion');
                    } else {
                        element.classList.remove('reduced-motion');
                    }
                });
                
                this.updateDashboard();
            }
            
            stressTest() {
                console.log('🧪 Running stress test...');
                
                // Create many observers to test memory management
                const stressObservers = [];
                for (let i = 0; i < 100; i++) {
                    const observer = new IntersectionObserver(() => {}, { threshold: 0.1 });
                    stressObservers.push(observer);
                }
                
                // Simulate rapid scroll events
                for (let i = 0; i < 1000; i++) {
                    window.dispatchEvent(new Event('scroll'));
                }
                
                setTimeout(() => {
                    // Cleanup stress test observers
                    stressObservers.forEach(observer => observer.disconnect());
                    console.log('✅ Stress test completed and cleaned up');
                }, 2000);
            }
            
            resetAnimations() {
                console.log('🔄 Resetting animations...');
                
                // Remove all animation classes
                document.querySelectorAll('.scroll-section, .stagger-item').forEach(element => {
                    element.classList.remove('visible', 'reduced-motion');
                    element.style.opacity = '0';
                    element.style.transform = '';
                });
                
                // Reset counters
                this.animatedElements.clear();
                this.animatedElementCount = 0;
                this.intersectionEventCount = 0;
                this.scrollEventCount = 0;
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                setTimeout(() => {
                    this.updateDashboard();
                    console.log('✅ Animations reset');
                }, 500);
            }
            
            generateReport() {
                const report = {
                    timestamp: new Date().toISOString(),
                    performance: {
                        fps: document.getElementById('fps').textContent,
                        memory: document.getElementById('memory').textContent,
                        scrollEvents: this.scrollEventCount,
                        intersectionEvents: this.intersectionEventCount,
                        animatedElements: this.animatedElementCount,
                        observers: this.observerCount
                    },
                    browser: {
                        userAgent: navigator.userAgent,
                        reducedMotionSupport: window.matchMedia('(prefers-reduced-motion)').media !== 'not all',
                        intersectionObserverSupport: 'IntersectionObserver' in window,
                        backdropFilterSupport: CSS.supports('backdrop-filter: blur(1px)'),
                        willChangeSupport: CSS.supports('will-change: transform'),
                        containSupport: CSS.supports('contain: layout')
                    },
                    features: {
                        prefersReducedMotion: this.prefersReducedMotion,
                        hasPerformanceMemory: !!performance.memory
                    }
                };
                
                console.group('📊 Animation Performance Report');
                console.log(report);
                console.groupEnd();
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `animation-performance-report-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                alert('Performance report generated and downloaded!');
            }
            
            cleanup() {
                // Cleanup all observers
                this.observers.forEach(observer => observer.disconnect());
                this.observers.clear();
                
                console.log('🧹 Performance test cleaned up');
            }
        }
        
        // Initialize performance test
        const performanceTest = new PerformanceTest();
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            performanceTest.cleanup();
        });
        
        // Log initial state
        console.log('🚀 GoEvent Animation Performance Test Started');
        console.log('📝 Scroll down to test animations');
        console.log('🎛️ Use the control panel to test different scenarios');
    </script>
</body>
</html>